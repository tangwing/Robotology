\section{Complément de l'algorithme}
La description de l'algorithme IAA qu'on a pu trouver n'est pas précise. Pour implémenter cet algorithme, il nous reste du travail à faire pour préciser tout l'algorithme. Le plus important est de fixer la condition d'arrêt de cet algorithme.


Pour cela, on considère deux cas possible que notre algorithme rencontrera:
\bigskip
\begin{enumerate}
	\item Le point cible est atteignable
	\item Le point cible n'est pas atteignable
\end{enumerate}


\subsection{Premier cas}
Pour le premier cas, l'algorithme doit s'arrêter quand la distance entre le point courant et le point cible est inférieur à une valeur prédéfinie (0.00001 par exemple), et il doit renvoyer l'ensemble des variable articulaires courantes.


La définition de la valeur de borne est très souple selon le problème réel. Par exemple dans le problème présenté dans le chapitre précédant, la précision n'est pas trop importante, car on peut dire sans problème que "une personne peut atteidre un point dans sa chambre si la distance entre ce point et le bout de son doigt est seulement 1mm". Dans notre implémentation, cette valeur est 0.0001, qui est à la fois assez petite et pas trop coûteuse par rapport au temp d'execution essentiel pour arriver à la fin de l'algorithme.


\subsection{Deuxieme cas}
Pour le deuxième cas, puisque le point cible n'est réelment pas atteignable, on ne va jamais avoir une distance assez petite entre le point courant et le point cible. En analysant l'algorithme, nous pensons intuitivement que l'algorithme doit s'arrêter quand il arrive un état "consistant". Ca veut dire que l'algorithme ne peut déjà pas améliorer aucune variable articulaire $\Theta_i$ dans deux itérations consécutives. 


Nous avons testé notre algorithme avec cette condition d'arrêt, mais le résultat n'est pas préférable. Après une analyse plus détaillée, nous avons pu trouver le truc : même si le point cible est atteignable, on peut aussi avoir des état consistant pendant l'execution de l'algorithme à cause de la valeur de \textsl{IncrementRate}. C'est assez raisonnable, car quand le changement est trop grand, c'est possible que aucun changement n'est utile pour améliorer le résultat, et c'est pour ça qu'on diminue la valeur \textsl{IncrementRate} en ce moment-là en apportant des changement plus délicats. Et donc, on ajoute une autre condition en dehors de la consistance d'état, c'est que la valeur de \textsl{IncrementRate} doit être assez petite pour assurer qu'il n'y a vraiment pas de possibilité d'améliorer le résultat.

BORNE[i]=0.000001/((QUAconfig[i].maxTheta - QUAconfig[i].minTheta)*180/PI);//precision:0.00...1°
%%%%%%%
En un mot, l'algorithme IAA (avec notre implémentation) doit s'arrêter quand l'une des deux conditions ci-après est vérifier: soit la distance entre le point courant et le point cible est inférieur à une valeur prédéfinie; soit la valeur de \textsl{IncrementRate} est inférieur à une valeur prédéfinie et les variables articulaires $\Theta$ ont un état consistant.


\section{Implémentation de l'algorithme IAA}
\subsection{Choix de langage}
Nous avons choisi C++ en tant que langage de programmation avec les considération ci-après:
\begin{itemize}
	\item Ce travail consiste à plutôt les calculs au lieu des logique commercials ou interface de interation. C'est très efficace d'utiliser C++ que les autre langages supérieurs.
	\item C++ possède des caratéristiques orienté-objet, qui peut nous faciliter
\end{itemize}} 


\section{Test de l'algorithme IAA}